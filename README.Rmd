---
title: "README"
author: "Leo-Yu-8859"
date: "2021/11/7"
output: md_document
---
# Simulation for missing dataset

## Create complete datasets

`create_df` can be used to create multivariable complete datasets with independent vairables having various distributions.
```{r}
source("create_df.R", local = knitr::knit_global(), echo = FALSE)
```

Arguments: 
1. n_count: A scalar specifying the number of complete datasets.

2. n_sample: A scalar specifying the sample size in each dataset.

3. n_x: A scalar specifying the number of independent variables in each dataset.

4. X_dist: A string vector of each independent variable's distribution. Default is NA which means all independent variables are follow a multivariate normal distribution.

5. mu: A numeric vector spesifying the mean of each independent variable, under X_dist=NA. Default is all zero.

6. sigma: The covariance matrix of independent variables, under X_dist=NA. Default is diagonal.

7. important: A numeric vector indicating which independent variables are important, i.e., in the linear regression model of generating dependent variable.

8. intercept: A scalar specifying the intercept in the linear regression model of generating dependent variable. Default is 0.

9. variance: A scalar specifying the variance of error in the linear regression model of generating dependent variable. Default is 1.

### Example

1. Create 10 complete datasets, with sample size equals to 100. There are five independent variables in each dataset and all follow the multivariate normal distribution with zero means and diagonal covariance matrix. Dependent variable is generated by the linear model: X1+X2+error, where error follow a normal distribution with zero mean and variance equaling to one.
```{r}
all_normal_data <- create_df(n_count = 10, n_sample = 100, n_x = 5, X_dist = NA, important = c(1,2))
```
```{r}
# the linear regression model of generating the dependent variable
all_normal_data$model
```
```{r}
# the independent variables' values of 3 cases in 10th dataset
head(all_normal_data$Xs[[10]],3)
```
```{r}
# the values of 3 cases in 10th dataset
head(all_normal_data$dfs[[10]],3)
```

2. Create 10 complete datasets, with sample size equals to 100. There are five independent variables in each dataset. Dependent variable is generated by the linear model: X1+X2+error, where error follow a normal distribution with zero mean and variance equaling to one.
```{r}
# the distributions of the independent variables
my_var <- c("rnorm(n=n_sample, 10,10)", "rnorm(n=n_sample, 0,100)",
          "rnorm(n=n_sample, 10,10)", "rnorm(n=n_sample, 0,100)",
          "rexp(n=n_sample, 1)")
my_var_data <- create_df(n_count = 10, n_sample = 100, n_x = 5, X_dist = my_var, important = c(1,2))
```
```{r}
# the linear regression model of generating the dependent variable
my_var_data$model
```
```{r}
# the independent variables' values of 3 cases in 10th dataset
head(my_var_data$Xs[[10]],3)
```
```{r}
# the values of 3 cases in 10th dataset
head(my_var_data$dfs[[10]],3)
```

## Ampute the aforementioned datasets

`ampute_df`, using MICE::ampute(), can be used to ampute the complete datasets, i.e. making some covariates missing.
```{r}
source("ampute_df.R", local = knitr::knit_global(), echo = FALSE)
```

Arguments:
1. n_count: A scalar specifying the number of complete datasets.

2. Xs: The list of the covariates' dataframes.

3. dfs: The list of the complete datasets.

4. prop: A scalar specifying the proportion of missingness. Should be a value between 0 and 1. Default is a missingness proportion of 0.5.

5. patterns: A matrix or data frame of size #patterns by #variables where 0 indicates that a variable should have missing values and 1 indicates that a variable should remain complete. The user may specify as many patterns as desired. One pattern (a vector) is possible as well. Default is a square matrix of size #variables where each pattern has missingness on one variable only (created with ampute.default.patterns). After the amputation procedure, md.pattern can be used to investigate the missing data patterns in the data.

6. freq: A vector of length #patterns containing the relative frequency with which the patterns should occur. For example, for three missing data patterns, the vector could be c(0.4, 0.4, 0.2), meaning that of all cases with missing values, 40 percent should have pattern 1, 40 percent pattern 2 and 20 percent pattern 3. The vector should sum to 1. Default is an equal probability for each pattern, created with ampute.default.freq.

7. bycases: Logical. If TRUE, the proportion of missingness is defined in terms of cases. If FALSE, the proportion of missingness is defined in terms of cells. Default is TRUE.

### Example

1. Ampute all_normal_data 
```{r}
amp_all_normal <- ampute_df(n_count = 10, Xs = all_normal_data$Xs, dfs = all_normal_data$dfs, prop=0.5, patterns=NULL, freq=NULL, bycases=TRUE)
```
```{r}
# the values of 3 cases in 10th amputed dataset
head(amp_all_normal$ampdf[[10]], 3)
```
```{r}
# the missing pattern of 10th amputed dataset
amp_all_normal$missing_pattern[[10]]
```

2. Ampute my_var_data
```{r}
amp_my_var <- ampute_df(n_count = 10, Xs = my_var_data$Xs, dfs = my_var_data$dfs, prop=0.5, patterns=NULL, freq=NULL, bycases=TRUE)
```
```{r}
# the values of 3 cases in 10th amputed dataset
head(amp_my_var$ampdf[[10]], 3)
```
```{r}
# the missing pattern of 10th amputed dataset
amp_my_var$missing_pattern[[10]]
```

## Impute with MICE

`impute_mice` specifies using MICE to impute and analyze the missing datasets.
```{r}
source("impute_mice.R", local = knitr::knit_global(), echo = FALSE)
```

Arguments:
1. n_count: A scalar specifying the number of complete datasets.

2. n_x: A scalar specifying the number of independent variables in each dataset.

3. ampdf: The list of amputed datasets

4. predictor_matrix: A numeric matrix of length(blocks) rows and ncol(data) columns, containing 0/1 data specifying the set of predictors to be used for each target column. Each row corresponds to a variable block, i.e., a set of variables to be imputed. A value of 1 means that the column variable is used as a predictor for the target block (in the rows). By default, the predictorMatrix is a square matrix of ncol(data) rows and columns with all 1's, except for the diagonal. Note: For two-level imputation models (which have "2l" in their names) other codes (e.g, 2 or -2) are also allowed.

5. m: Number of multiple imputations. The default is m=5.

6. meth: Can be either a single string, or a vector of strings with length length(blocks), specifying the imputation method to be used for each column in data. If specified as a single string, the same method will be used for all blocks. The default imputation method (when no argument is specified) depends on the measurement level of the target column, as regulated by the defaultMethod argument. Columns that need not be imputed have the empty method "". See details.

7. lm_expr: A string specifies the expression showing which variables should be place in the analysis model.

8. alpha: A numeric value specifies the significance level of the analysis model. The Default is 0.05.

### Example

1. Impute all_normal using impute_mice()
```{r}
all_normal_mice <- impute_mice(n_count = 10, n_x = 5, ampdf = amp_all_normal$ampdf, lm_expr = all_normal_data$lm)
```
```{r}
# output the mean of the pooled estimate, lambda, within-variance, between-variance and the total variance of the pooled estimate. 
all_normal_mice$mean_output
```
```{r}
# for each variable, output the frequency of the p-value larger than alpha.
all_normal_mice$p.value_freq
```
```{r}
# runtime
all_normal_mice$runtime
```

2. Impute my_var using impute_mice()
```{r}
my_var_mice <- impute_mice(n_count = 10, n_x = 5, ampdf = amp_my_var$ampdf, lm_expr = my_var_data$lm)
```
```{r}
# output the mean of the pooled estimate, lambda, within-variance, between-variance and the total variance of the pooled estimate. 
my_var_mice$mean_output
```
```{r}
# for each variable, output the frequency of which the p-value is larger than alpha.
my_var_mice$p.value_freq
```
```{r}
# runtime
my_var_mice$runtime
```

## Impute with kNN

`impute_kNN` specifies using VIM::kNN to impute and analyze the missing datasets.
```{r}
source("impute_kNN.R", local = knitr::knit_global(), echo = FALSE)
```

Arguments:
1. n_count: A scalar specifying the number of complete datasets.

2. n_x: A scalar specifying the number of independent variables in each dataset.

3. ampdf: The list of amputed datasets.

4. k: A scalar or numeric vector of Nearest Neighbours used.

5. dist_var: Variables to be used for distance calculation. Default is all the variables.

6. weights: Weights for the variables for distance calculation. If weights = "auto" weights will be selected based on variable importance from random forest regression, using function ranger::ranger(). Weights are calculated for each variable seperately. Default is NULL.

7. numFun: 	Function for aggregating the k Nearest Neighbours in the case of a numerical variable. Default is the median.

8. catFun:	Function for aggregating the k Nearest Neighbours in the case of a categorical variable. Default is the function maxCat.

9. weightDist: TRUE/FALSE if the distances of the k nearest neighbours should be used as weights in the aggregation step. Default is FALSE.

10. alpha: A numeric value specifies the significance level of the analysis model. The Default is 0.05.

11. lm_expr: A string specifies the expression showing which variables should be place in the analysis model.

### Example

1. Impute all_normal using impute_kNN()
```{r}
all_normal_kNN <- impute_kNN(n_count = 10, n_x = 5, ampdf = amp_all_normal$ampdf, k = c(1,3,5,7,9), lm_expr = all_normal_data$lm)
```
```{r}
# output the mean of the pooled estimate, lambda, within-variance, between-variance and the total variance of the pooled estimate. 
all_normal_kNN$mean_output
```
```{r}
# for each variable, output the frequency of the p-value larger than alpha.
all_normal_kNN$p.value_freq
```
```{r}
# runtime
all_normal_kNN$runtime
```

2. Impute my_var using impute_kNN()
```{r}
my_var_kNN <- impute_kNN(n_count = 10, n_x = 5, ampdf = amp_my_var$ampdf, k = c(1,3,5,7,9), lm_expr = my_var_data$lm)
```
```{r}
# output the mean of the pooled estimate, lambda, within-variance, between-variance and the total variance of the pooled estimate. 
my_var_kNN$mean_output
```
```{r}
# for each variable, output the frequency of which the p-value is larger than alpha.
my_var_kNN$p.value_freq
```
```{r}
# runtime
my_var_kNN$runtime
```

## Impute with hot.deck()

`impute_hd` specifies using hot.deck::hot.deck to impute and analyze the missing datasets.
```{r}
source("impute_hd.R", local = knitr::knit_global(), echo = FALSE)
```

Arguments:
1. n_count: A scalar specifying the number of complete datasets.

2. n_x: A scalar specifying the number of independent variables in each dataset.

3. ampdf: The list of amputed datasets

4. m: Number of multiple imputations. The default is m=5.

5. method: Method used to draw donors based on affinity either “best.cell” (the default) or “p.draw” for probabilistic draw.

6. sdCutoff: Number of standard deviations between observations such that observations fewer than sdCutoff standard deviations away from each other are considered sufficiently close to be a match, otherwise they are considered too far away to be a match. Default is 1.

7. alpha: A numeric value specifies the significance level of the analysis model. The Default is 0.05.

8. lm_expr: A string specifies the expression showing which variables should be place in the analysis model.

### Example

1. Impute all_normal using impute_hd()
```{r}
all_normal_hd <- impute_hd(n_count = 10, n_x = 5, ampdf = amp_all_normal$ampdf, sdCutoff = 5, lm_expr = all_normal_data$lm)
```
```{r}
# output the mean of the pooled estimate, lambda, within-variance, between-variance and the total variance of the pooled estimate. 
all_normal_hd$mean_output
```
```{r}
# for each variable, output the frequency of the p-value larger than alpha.
all_normal_hd$p.value_freq
```
```{r}
# runtime
all_normal_hd$runtime
```

2. Impute my_var using impute_hd()
```{r}
my_var_hd <- impute_hd(n_count = 10, n_x = 5, ampdf = amp_my_var$ampdf, method = "p.draw", lm_expr = my_var_data$lm)
```
```{r}
# output the mean of the pooled estimate, lambda, within-variance, between-variance and the total variance of the pooled estimate. 
my_var_hd$mean_output
```
```{r}
# for each variable, output the frequency of which the p-value is larger than alpha.
my_var_hd$p.value_freq
```
```{r}
#runtime
my_var_hd$runtime
```


